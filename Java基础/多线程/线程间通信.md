# 线程间通信涉及的方法

- 线程间通讯:其实就是多个线程在操作同一个资源,但是操作的动作不同.
----
## 等待/唤醒机制涉及的方法(操作共享数据的时候使用)：
1. wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中
2. notify()：唤醒线程池中的一个线程(任何一个都有可能)(通常唤醒第一个被等待的)
3. notifyAll()：唤醒线程池中的所有线程   
线程建立的时候,在内存中会建立一个线程池,等待线程都存在线程池中

## 注意
1. 三个方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法,要对持有监视器(锁)的线程进行操作,只有同步才具有锁
2. **必须要明确到底操作的是哪个锁上的线程！**
3. 必须要标识出wait()它所操作的线程所属的锁( 例:this.wait() )
4. wait和sleep区别？
    >1. wait可以指定时间也可以不指定。sleep必须指定时间。
    >2. 在同步中时，对CPU的执行权和锁的处理不同。wait：释放执行权，释放锁。sleep：释放执行权，不释放锁。

- 为什么操作线程的方法wait、notify、notifyAll定义在了object类中?
>因为这些方法是监视器的方法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定在object类中。

----

# 等待/唤醒机制
等待/唤醒机制。也就是常见的生产者消费者问题。

	1. 当多个生产者消费者出现时，
	需要让获取执行权的线程判断标记。
	通过while完成。

	2. 需要将对方的线程唤醒。
	仅仅用notify，是不可以的。因为有可能出现只唤醒本方。
	有可能会导致，所有线程都等待。
	所以可以通过notifyAll()的形式来完成 。

- 这时有一个问题。就是每次notifyAll()时都会唤醒本方。可不可以只唤醒对方呢？

### JDK1.5版本提供了一些新的对象，优化了等待唤醒机制。

* 将synchronized 替换成了Lock接口。
	将隐式锁，升级成了显示锁。
>  Lock
>* 获取锁：lock();  
>* 释放锁：unlock();注意：释放的动作一定要执行，所以通常定义在finally中。  
>* 获取Condition对象：newCondition();  

* 将Object中的wait，notify，notifyAll方法都替换成了Condition的await()，signal()，signalAll()。
>和以前不同是：一个同步代码块具备一个锁，该锁具备自己的独立wait()和notify()方法。
>现在是将wait()，notify()等方法，封装进一个特有的对象Condition，而同一个Lock锁上可以有多个Condition对象。

```
	Lock lock = new ReentrantLock();

	Condition conA = lock.newCondition();
	Condition conB = lock.newCondition();

	con.await();//生产，，消费

	con.signal();生产

	set()
	{
		if(flag)
			conA.await();//生产者，
		code......;

		flag = true;
		conB.signal();
	}
	
	out()
	{
		if(!flag)
			conB.await();//消费者

		code....;
		flag = false;
		conA.signal();
	}

```
```
synchronized(锁)
{
	wait();
}
```

## 停止线程方法：
stop()方法已过时。  
原理：run方法结束。run方法中通常定义循环，指定控制住循环线程即可结束。

1. 定义结束标记。
2. 当线程处于了冻结状态，没有执行标记，程序一样无法结束。
    这时可以循环，正常退出冻结状态，或者强制结束冻结状态。
3. 强制结束冻结状态：interrupt();目的是线程强制从冻结状态恢复到运行状态。
    但是会发生InterruptedException异常(需要处理异常)。


## 线程中其他一些常见方法：
* setDaemon(boolean):将线程标记为后台线程，后台线程和前台线程一样，开启，一样抢执行权运行，
只有在结束时，有区别，当前台线程都运行结束后，后台线程会自动结束。(依赖于前台线程)

* join():什么意思？等待该线程结束。当A线程执行到了B的.join方法时，A就会处于冻结状态。A什么时候运行呢？当B运行结束后，A就会具备运行资格，继续运行。加入线程，可以完成对某个线程的临时加入执行。

	

## 多线程重点：
1. 多线程的创建的两种方式，以及区别。

2. 同步的特点   
	同步的好处：  
	同步的弊端：  
	同步的前提：  
	同步的表现形式以及区别。  
	特例：static同步函数锁是哪一个。  
	死锁代码要求写的出来。


3. 线程间通信，看以上总结。


4. wait和sleep，yield：临时暂停，可以让线程是释放执行权。


